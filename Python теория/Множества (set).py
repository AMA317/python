#МНОЖЕСТВО или SET(на англисйком) - неупорядоченная коллекция уникальных элиментов (отстутствуют повторяющиеся значаение) и состоят из не изменяемых элиментов (строки, числа и кортежи)

#создание:
#переменная = {через запятую перечселяем элименты}

a = {1,2,3,3,2,5,6}
b = {'hi', 'ha', 'ho', 'hi','ha','ho','hi'}
c = set('abcdfresdf') #множество можно создавать с помощью функции set. Здесь создаем множество из строки
d = set([1,2,3,2,1,4,3]) #создание множества из списка
e = set(range(5)) #создание множества из функции range, не смотря на то что мы просто получим значения от 0 до 5, но фигурный скобки будут вссе равно указывать на то что это множество

f = set() #создание пустого множества

a = [1,2,3,1,2,4,5,3,2,] #имеем список элиментов из которых нужно исключить все дубли
a = list(set(a)) # 1) вызываем функци set, которая превращает это все в множетсво 2) множество превращаем обратно в списко с помощью list 3) перезаписваем все обратно в a
#print(a)

#ДОБАВЛЕНИЕ ЭЛИМЕНТА
b = {12, 13, 45, 54, 21, 12}
b.add(9) #имямножетсва.функция add(занчение которое хотим добавить, оно может быть тоьлко одним)
b.add(12) #в случсе добавления уже имеющегосяэлиментничего не произойдет
#print(b)
#ДОБАВЛЕНИЕ НЕСКОЛЬКИХ ЭЛИМЕНТОВ В МНОЖЕСТВО
b.update([7,5,7,3,5,3])#метод update принимает итерабельную последовательность (списки, строки, range, само множество), это удобно тем что сразу можно добавлять несколько объектов
#print(b)

#УДАЛЕНИЕ ЭЛИМЕНТА
с = {54,32,54,3,4,2}
c.discard(4) #если несколько раз попытаться удалить одн и тот же элимент, то все будет работать, ошбки не будет
c.discard(4)
#ВТОРОЙ СПОСОБ УДАЛЕНИЯ ЭЛИМЕНТА
#c.remove(54) #вроде то же самое, но нет. Если мы хотим повторно удалить элимент их множетсва или удалить элимент, которого небыло, то будет ошибка
#c.remove(3)
#print(c)

#МЕТОД POP - удаление элимента из множетсва, при попытке удалить элимент, которого нету в множестве произойдет ошибка
h = {54,32,54,3,4,2}
#print(h.pop())
#print(h)

#МЕТОД CLEAR - очищение всех элиментов множетсва
v = {54,32,54,3,4,2}
#print(v) #до того как мы преминили метод
v.clear()
#print(v) #после того как применили метод

#ОПЕРАЦИИ НАД МНОЖЕСТВАМИ
f = {54,32,54,3,4,2}
print(len(f)) #длина списка, но БЕЗ дублей
print(4 in a) #узнаем есть ли элимент во множетсве
print(4 in a, 7 in a)
print(4 in a, 7 not in a) #not длеает отрицание, получается что мы спрашиваем: 7 нету в нашем множестве ?

p1 = {4,3,1,2}
p2 = {4,3,7,5,6}
print(p1 & p2) #поиск элиментов, которое есть в обоих множетсвах (объединение)
p3 = {8,9,10,15,20}
print(p1 & p3) #если нет элиментов входящих и в p1 и в p3, то выведится пустое множество (при этом ни множетсво p1 и p3 не изменились)

p1 &= p3 #это для того что если мы хотим во множество a запсиать результат персеечния множеств a и c
print(a,c)

print(p1.intersection(p2)) #то же самое что и p1 & p2, но уже с помощью метода intersection
print(p1.intersection_update(p3)) #то же самое что и a &= c, только с помощью метода intersection_update

g = {4,3,1,2}
l = {4,3,7,5,6}
print(g.union(l)) #все элименты входящие в оба множества, но без дублей (объединения)
print(g, l) #вдим что после объединения двех множеств сами эти множества не изменились

g = g.union(l) #десб же уже, множество g примет результат обединения с множесвтом l
print(g)

q1 = {4,3,1,2}
q2 = {4,3,7,5,6}
print(q1 - q2) #вычетания множеств. Из множетсва q1 мы вычитаем все значения пересекающихс со множеством q2
print(q2 - q1) #останутся только те элименты, которые не входят во множество q1
#при таких операциях множетсва не изменяются, для того чтобы изменить множество:
q1 -= q2
print(q1) #то есть мы в множестве q1 поменяли значения, на те значения которые отсаются при q1 - q2

v1 = {4,3,1,2}
v2 = {4,3,7,5,6}
print(v1 ^ v2) #симетричная разность, результатом будут все элименты за исключения тех, которые оддновременно принадлежат этим множетсвам

i1 = {4,3,1,2}
i2 = {4,3,7,5,6}
print(i1 == i2) #сравниваем 2 множетсва, они бдут равны когда у них будт одинаковое кол-во элиментов и сами элименты(ьез дублей) будут равны
i1 = {4,3,1,2}
i2 = {4,3,1,2,1,4}
print(i1 == i2) #множества будту равны, т.к. дубли убираются

print(i1 > i2) #проверяем лежат ли все элименты одного множетсва у другом,если да, то результат True
print(i1 <= i2)

#ОБХОД ЭЛИМЕНТОВ МНОЖЕТСВА по значениям, по индексам нельзя, т.к. множества не поддерживают индексацию
w = {4,3,2,1}
for i in w:
    print(i)